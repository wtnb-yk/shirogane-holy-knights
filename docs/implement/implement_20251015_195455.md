# 実装詳細: モーダル間遷移アニメーション問題の解決

## 実装日時
2025-10-15 19:54:55

## 関連ファイル
- プランファイル: `docs/plan/plan_20251015_102645.md`
- 調査ファイル: `docs/investigate/investigate_20251015_102250.md`

## 実装概要
コンテンツコンテナパターンを採用し、単一のResponsiveModalを維持したまま内部でコンテンツをシームレスに切り替えることで、モーダル間遷移アニメーション問題を解決しました。

## 実装したタスク

### タスク1: globals.cssにコンテンツ遷移用アニメーション追加 ✅
**ファイル**: `frontend/src/app/globals.css`

**追加内容**:
```css
/* コンテンツ遷移用アニメーション */
@keyframes contentSlideLeft {
  from {
    opacity: 0;
    transform: translateX(-20px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes contentSlideRight {
  from {
    opacity: 0;
    transform: translateX(20px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes contentFadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

.animate-content-slide-left {
  animation: contentSlideLeft 300ms ease-in-out;
}

.animate-content-slide-right {
  animation: contentSlideRight 300ms ease-in-out;
}

.animate-content-fade-in {
  animation: contentFadeIn 300ms ease-in-out;
}
```

**追加位置**: 636行目（ファイル末尾）

---

### タスク2: ModalContentContainerコンポーネント作成 ✅
**ファイル**: `frontend/src/components/Modal/ModalContentContainer.tsx`（新規作成）

**実装内容**:
- ジェネリック型`<T extends string>`を使用した汎用設計
- `ModalContentItem<T>`インターフェース: mode, content, transitionDirectionを定義
- `ModalContentContainerProps<T>`インターフェース: currentMode, contents, transitionDuration, classNameを定義
- absolute positioningで複数コンテンツをオーバーレイ
- currentModeに基づいてアクティブなコンテンツを判定
- 非アクティブなコンテンツには`pointer-events-none`と`aria-hidden="true"`を適用
- opacity + translateXでアニメーション（transition-all duration-300 ease-in-out）
- アクセシビリティ対応（ARIA属性、role）

**主要コード**:
```typescript
export interface ModalContentItem<T extends string = string> {
  mode: T;
  content: React.ReactNode;
  transitionDirection?: 'left' | 'right';
}

export interface ModalContentContainerProps<T extends string = string> {
  currentMode: T;
  contents: ModalContentItem<T>[];
  transitionDuration?: number;
  className?: string;
}
```

**将来の拡張性**: プロフィール編集、設定、ウィザード形式のフォーム等にも再利用可能

---

### タスク3: CalendarModalContentContainerコンポーネント作成 ✅
**ファイル**: `frontend/src/features/calendar/components/modals/internals/CalendarModalContentContainer.tsx`（新規作成）

**実装内容**:
- ModalContentContainerを使用
- `CalendarModalMode`型: 'dayEvents' | 'eventDetail'
- mode='dayEvents'の場合: DayEventsListまたはEmptyEventsMessageを表示（transitionDirection='left'）
- mode='eventDetail'の場合: EventTitle、EventImage、EventTimeInfo、EventDescriptionを表示（transitionDirection='right'）
- 既存の内部コンポーネントを全て再利用

**主要コード**:
```typescript
const contents: ModalContentItem<CalendarModalMode>[] = [
  {
    mode: 'dayEvents',
    transitionDirection: 'left',
    content: (/* DayEventsList または EmptyEventsMessage */),
  },
  {
    mode: 'eventDetail',
    transitionDirection: 'right',
    content: selectedEvent ? (/* EventTitle, EventImage等 */) : null,
  },
];
```

---

### タスク4: calendar/page.tsxリファクタリング ✅
**ファイル**: `frontend/src/app/calendar/page.tsx`

**変更内容**:

1. **importの更新**:
   - 削除: `DayEventsModal`, `EventDetailModal`
   - 追加: `CalendarModalContentContainer`, `CalendarModalMode`, `ResponsiveModal`

2. **状態統合**:
   ```typescript
   // Before
   const [isDayEventsModalOpen, setIsDayEventsModalOpen] = useState(false);
   // useCalendarフックから: isEventModalOpen, setIsEventModalOpen

   // After
   const [calendarModalOpen, setCalendarModalOpen] = useState(false);
   const [calendarModalMode, setCalendarModalMode] = useState<CalendarModalMode>('dayEvents');
   ```

3. **ハンドラー関数簡素化**:
   - `handleEventClick`: モードを'eventDetail'に設定してモーダルを開く
   - `handleDateClick`: モードを'dayEvents'に設定してモーダルを開く
   - `handleEventClickFromDayModal`: モードを'eventDetail'に変更（モーダルは閉じない）
   - `handleBackToDayModal`: モードを'dayEvents'に戻す（モーダルは閉じない）
   - `handleCloseModal`: 全ての状態をリセット

4. **単一ResponsiveModal実装**:
   - タイトルをcalendarModalModeに基づいて動的に変更
   - backButtonをcalendarModalModeとfromDayModalOrSheetに基づいて動的に制御
   - CalendarModalContentContainerを使用

---

### タスク5: 既存モーダルコンポーネント削除 ✅
**削除ファイル**:
- `frontend/src/features/calendar/components/modals/DayEventsModal.tsx`
- `frontend/src/features/calendar/components/modals/EventDetailModal.tsx`

**確認事項**:
- 他のファイルでの使用箇所がないことを確認（Grepで検索済み）

---

### タスク6: E2Eテスト実装（Playwright MCP） ⏸️
**状態**: 保留（ブラウザが既に使用中のため後で実施）

**実施予定のテストシナリオ**:
1. **基本フロー**: 日付クリック → イベント詳細 → 戻る → 閉じる
2. **直接EventDetail開くケース**
3. **モバイル表示確認**（375x667）
4. **デスクトップ表示確認**（1920x1080）
5. **アクセシビリティ確認**

---

## ビルド結果
✅ ビルド成功（エラーなし）

```
Route (app)                                 Size  First Load JS
┌ ○ /                                    6.51 kB         130 kB
├ ○ /_not-found                            995 B         103 kB
├ ○ /about                                1.9 kB         115 kB
├ ○ /archives                            10.9 kB         142 kB
├ ○ /calendar                              11 kB         133 kB
├ ○ /discography                         10.9 kB         138 kB
├ ○ /news                                5.67 kB         137 kB
├ ○ /robots.txt                            144 B         102 kB
├ ○ /sitemap.xml                           144 B         102 kB
├ ○ /songs                               11.3 kB         142 kB
└ ○ /specials                            6.81 kB         120 kB
```

---

## 実装時の修正
### 型エラー修正
**問題**: CalendarModalContentContainerで`date`パラメータが使用されていない

**解決策**: `date`パラメータをpropsから削除
- CalendarModalContentContainerPropsから`date: Date | null`を削除
- calendar/page.tsxでのCalendarModalContentContainer呼び出しから`date={selectedDate}`を削除

---

## 期待される効果
### 実装済み
- ✅ 状態管理が統合され、コードの可読性・保守性が向上
- ✅ 汎用的なModalContentContainerにより、将来的な拡張が容易
- ✅ コンポーネント数の削減（2つのモーダル → 1つのモーダル + 2つのコンテナ）
- ✅ ビルドエラーなし

### 確認待ち（E2Eテスト実施後）
- ⏸️ モーダル開閉アニメーションが発生せず、コンテンツがシームレスに切り替わる（300ms）
- ⏸️ 戻るボタンで正常にDayEventsに戻れる
- ⏸️ デスクトップとモバイルの両方で正常に動作する
- ⏸️ コンソールエラーが発生しない

---

## 残りのタスク
1. E2Eテストの実施（Playwright MCPまたは手動テスト）
2. コンソールエラーの確認
3. 実際の動作確認（モーダル遷移のスムーズさ）

---

## 技術的な学び
### CSS Transitionを使用したアニメーション
- absolute positioningで複数コンテンツをオーバーレイ
- opacity + translateXでスムーズな遷移を実現
- transition-allで全てのプロパティをアニメーション
- transitionDurationをpropsで指定可能にして柔軟性を確保

### ジェネリック型を使用した汎用コンポーネント設計
- `<T extends string>`で任意のモード型に対応
- 型安全性を保ちながら再利用可能なコンポーネントを実現

### アクセシビリティ対応
- aria-hidden属性で非表示コンテンツをスクリーンリーダーから隠す
- role="region"で領域を明示
- aria-label属性でコンテンツの説明を提供

---

## 次のステップ
1. E2Eテストの実施
2. 実際の動作確認
3. コンソールエラーの確認
4. 問題なければコミット作成

---

## ステータス
**現在**: 実装完了、E2Eテスト保留
**次**: TEST（E2Eテスト実施）
