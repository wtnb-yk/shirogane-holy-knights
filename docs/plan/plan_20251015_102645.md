# 実装プラン: モーダル間遷移アニメーション問題の解決

## プラン策定日時
2025-10-15 10:26:45

## 前提となる調査結果
- 調査ファイル: `docs/investigate/investigate_20251015_102250.md`
- ブランチ: `feature/improve-modal-mobile-ux`

## 実装方針

### 採用パターン
**パターン4（コンテンツコンテナパターン）を採用**
- 単一のResponsiveModalを維持し、内部でコンテンツを切り替え
- モーダル自体は常に開いたまま、中身だけがシームレスに遷移
- 実装難易度と効果のバランスが最適
- 汎用的な抽象コンポーネントを先に実装し、将来の拡張性を確保

### アーキテクチャ設計

```
ModalContentContainer (汎用抽象コンポーネント)
  ↓ 使用
CalendarModalContentContainer (カレンダー特化実装)
  ↓ 使用
calendar/page.tsx (単一ResponsiveModal)
```

## ファイル変更計画

### 新規作成

#### 1. ModalContentContainer.tsx（汎用抽象コンポーネント）
- **パス**: `frontend/src/components/Modal/ModalContentContainer.tsx`
- **役割**: モーダル内での画面遷移を管理する汎用コンテナ
- **機能**:
  - 任意の数のコンテンツを受け取る
  - currentModeに基づいてコンテンツを切り替え
  - フェード + スライドアニメーションを提供
  - 遷移方向（left/right）をカスタマイズ可能
  - 完全に再利用可能な設計

**インターフェース設計**:
```typescript
interface ModalContentItem<T extends string = string> {
  mode: T;
  content: React.ReactNode;
  transitionDirection?: 'left' | 'right';
}

interface ModalContentContainerProps<T extends string = string> {
  currentMode: T;
  contents: ModalContentItem<T>[];
  transitionDuration?: number; // デフォルト: 300ms
  className?: string;
}
```

#### 2. CalendarModalContentContainer.tsx（カレンダー特化実装）
- **パス**: `frontend/src/features/calendar/components/modals/internals/CalendarModalContentContainer.tsx`
- **役割**: カレンダーモーダル用のコンテンツコンテナ
- **機能**:
  - ModalContentContainerを使用
  - DayEventsとEventDetailのコンテンツを管理
  - カレンダー固有のpropsを受け取り、適切なコンテンツを構築

**インターフェース設計**:
```typescript
type CalendarModalMode = 'dayEvents' | 'eventDetail';

interface CalendarModalContentContainerProps {
  mode: CalendarModalMode;
  // DayEvents用
  date: Date | null;
  events: Event[];
  onEventClick: (event: Event) => void;
  // EventDetail用
  selectedEvent: Event | null;
}
```

### 修正

#### 3. calendar/page.tsx
**変更内容**:
- 状態管理を統合
  - 削除: `isDayEventsModalOpen`, `isEventModalOpen`
  - 追加: `calendarModalOpen`, `calendarModalMode`
- 単一のResponsiveModalで両方のコンテンツを管理
- タイトル・戻るボタンの動的制御
- ハンドラー関数の簡素化

**主な変更点**:
```typescript
// Before
const [isDayEventsModalOpen, setIsDayEventsModalOpen] = useState(false);
const [isEventModalOpen, setIsEventModalOpen] = useState(false);

// After
const [calendarModalOpen, setCalendarModalOpen] = useState(false);
const [calendarModalMode, setCalendarModalMode] = useState<'dayEvents' | 'eventDetail'>('dayEvents');
```

#### 4. globals.css
**追加内容**:
- コンテンツ遷移用のkeyframes
  - `contentSlideLeft`: 左からスライドイン
  - `contentSlideRight`: 右からスライドイン
  - `contentFadeIn`: フェードイン
- アニメーションクラス
  - `.animate-content-slide-left`
  - `.animate-content-slide-right`
  - `.animate-content-fade-in`

### 削除

#### 5. DayEventsModal.tsx
- **パス**: `frontend/src/features/calendar/components/modals/DayEventsModal.tsx`
- **理由**: 単一のResponsiveModalに統合されるため不要

#### 6. EventDetailModal.tsx
- **パス**: `frontend/src/features/calendar/components/modals/EventDetailModal.tsx`
- **理由**: 単一のResponsiveModalに統合されるため不要

## 詳細タスク分解

### タスク1: ModalContentContainerコンポーネント作成
**優先度**: 最高

**実装内容**:
1. ジェネリック型を使用した柔軟な設計
2. currentModeに基づいてアクティブなコンテンツを判定
3. 非アクティブなコンテンツには`pointer-events-none`を適用
4. CSSトランジションによるスムーズな切り替え
5. 遷移方向（left/right）のカスタマイズ対応
6. アクセシビリティ（ARIA属性、role）の考慮

**技術的詳細**:
- absolute positioningで複数コンテンツをオーバーレイ
- opacity + translateXでアニメーション
- transition-all duration-300 ease-in-out
- aria-hidden属性で非表示コンテンツをスクリーンリーダーから隠す

### タスク2: CalendarModalContentContainerコンポーネント作成
**優先度**: 高

**実装内容**:
1. ModalContentContainerを使用
2. mode='dayEvents'の場合:
   - DayEventsListまたはEmptyEventsMessageを表示
   - transitionDirection='left'
3. mode='eventDetail'の場合:
   - EventTitle、EventImage、EventTimeInfo、EventDescriptionを表示
   - transitionDirection='right'
4. 既存の内部コンポーネントを再利用

**依存関係**:
- タスク1の完了が前提

### タスク3: globals.cssアニメーション追加
**優先度**: 高

**実装内容**:
```css
@keyframes contentSlideLeft {
  from {
    opacity: 0;
    transform: translateX(-20px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes contentSlideRight {
  from {
    opacity: 0;
    transform: translateX(20px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes contentFadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
```

### タスク4: calendar/page.tsxリファクタリング
**優先度**: 高

**実装内容**:
1. 状態を統合
   ```typescript
   const [calendarModalOpen, setCalendarModalOpen] = useState(false);
   const [calendarModalMode, setCalendarModalMode] = useState<'dayEvents' | 'eventDetail'>('dayEvents');
   ```

2. ハンドラー関数を簡素化
   ```typescript
   const handleDateClick = (date: Date, events: any[]) => {
     setSelectedDate(date);
     setSelectedDateEvents(events);
     setCalendarModalMode('dayEvents');
     setCalendarModalOpen(true);
   };

   const handleEventClickFromDayModal = (event: any) => {
     setSelectedEvent(event);
     setCalendarModalMode('eventDetail');
     setFromDayModalOrSheet(true);
     // モーダルは閉じない
   };

   const handleBackToDayModal = () => {
     setCalendarModalMode('dayEvents');
     // モーダルは閉じない
   };

   const handleCloseModal = () => {
     setSelectedEvent(null);
     setCalendarModalOpen(false);
     setSelectedDate(null);
     setSelectedDateEvents([]);
     setFromDayModalOrSheet(false);
   };
   ```

3. 単一のResponsiveModal実装
   ```typescript
   <ResponsiveModal
     isOpen={calendarModalOpen}
     onClose={handleCloseModal}
     title={calendarModalMode === 'dayEvents'
       ? `${selectedDate?.toLocaleDateString('ja-JP')}のイベント`
       : 'イベント詳細'
     }
     backButton={calendarModalMode === 'eventDetail' && fromDayModalOrSheet ? {
       show: true,
       onClick: handleBackToDayModal
     } : undefined}
     mobileVariant="fullScreen"
   >
     <CalendarModalContentContainer
       mode={calendarModalMode}
       date={selectedDate}
       events={selectedDateEvents}
       selectedEvent={selectedEvent}
       onEventClick={handleEventClickFromDayModal}
     />
   </ResponsiveModal>
   ```

**依存関係**:
- タスク2の完了が前提

### タスク5: 既存モーダルコンポーネント削除
**優先度**: 中

**実装内容**:
1. DayEventsModal.tsxを削除
2. EventDetailModal.tsxを削除
3. calendar/page.tsxからのimportを削除
4. 他のファイルでの使用箇所がないか確認（Grepで検索）

**依存関係**:
- タスク4の完了が前提

### タスク6: E2Eテスト実装（Playwright MCP）
**優先度**: 最高

**テストシナリオ**:

1. **基本フロー: 日付クリック → イベント詳細 → 戻る → 閉じる**
   ```typescript
   // 1. カレンダーページに移動
   // 2. 日付をクリック
   // 3. DayEventsが表示されることを確認
   // 4. アニメーションが完了するまで待機
   // 5. イベントをクリック
   // 6. EventDetailに遷移することを確認（モーダルは開いたまま）
   // 7. スライドアニメーションの確認
   // 8. 戻るボタンをクリック
   // 9. DayEventsに戻ることを確認（モーダルは開いたまま）
   // 10. 閉じるボタンをクリック
   // 11. モーダルが閉じることを確認
   ```

2. **直接EventDetail開くケース**
   ```typescript
   // 1. カレンダーページに移動
   // 2. イベントバッジを直接クリック
   // 3. EventDetailが表示されることを確認
   // 4. 戻るボタンが表示されないことを確認
   // 5. 閉じるボタンで閉じることを確認
   ```

3. **モバイル表示確認**
   ```typescript
   // 1. ビューポートをモバイルサイズに変更（375x667）
   // 2. 全画面モーダルとして表示されることを確認
   // 3. 基本フローを実行
   // 4. アニメーションがスムーズに動作することを確認
   ```

4. **デスクトップ表示確認**
   ```typescript
   // 1. ビューポートをデスクトップサイズに変更（1920x1080）
   // 2. 中央モーダルとして表示されることを確認
   // 3. 基本フローを実行
   ```

5. **アクセシビリティ確認**
   ```typescript
   // 1. キーボードナビゲーション（Tab、Enter、Escape）
   // 2. フォーカス管理の確認
   // 3. ARIA属性の確認
   ```

**実装方法**:
- Playwright MCPツールを使用
- http://localhost:3001/calendar で実行
- スクリーンショットで視覚的な確認
- コンソールエラーの確認

**依存関係**:
- タスク1〜5の完了が前提

## テスト戦略

### 単体テスト
**対象**: ModalContentContainer.tsx
- 複数コンテンツの切り替えが正しく動作するか
- 非アクティブなコンテンツにpointer-events-noneが適用されるか
- ARIA属性が適切に設定されるか

### 統合テスト
**対象**: CalendarModalContentContainer.tsx
- DayEvents ⇄ EventDetailの遷移が正常に動作するか
- 空のイベントリストの場合のハンドリング
- propsの変更に正しく反応するか

### E2Eテスト
**対象**: calendar/page.tsx（タスク6に詳細記載）
- ユーザー操作フローの完全な再現
- アニメーションの視覚的確認
- デバイス別の動作確認

## リスク分析と対策

| リスク | 影響度 | 発生確率 | 対策 |
|--------|--------|----------|------|
| モード管理のバグ | 中 | 低 | 状態遷移図の作成、綿密なテストケース |
| アクセシビリティ問題 | 中 | 中 | ARIAラベル確認、スクリーンリーダーテスト |
| 直接EventDetail開くケースの不具合 | 低 | 低 | モード初期値の適切な設定、E2Eテストで確認 |
| アニメーション不具合 | 低 | 中 | 複数デバイス・ブラウザでの動作確認 |
| 既存機能の破壊 | 高 | 低 | 既存のE2Eテストを全て実行、リグレッションテスト |
| パフォーマンス劣化 | 低 | 低 | Chrome DevToolsでパフォーマンス計測 |

## 期待される効果

### ユーザー体験の向上
- ✅ モーダル開閉アニメーションが発生しなくなる
- ✅ コンテンツがシームレスに切り替わる（300ms）
- ✅ 操作の連続性が保たれる
- ✅ 自然で直感的な画面遷移

### コード品質の向上
- ✅ 状態管理が統合され、可読性が向上
- ✅ 汎用的なModalContentContainerにより再利用性が向上
- ✅ 将来的な拡張（他のモーダルでの画面遷移）が容易
- ✅ 責務の分離（汎用ロジック vs カレンダー固有ロジック）

### 保守性の向上
- ✅ コンポーネント数の削減（2つのモーダル → 1つのモーダル + 2つのコンテナ）
- ✅ 状態の一元管理
- ✅ テストがしやすい構造

## 実装順序

1. **タスク3**: globals.cssアニメーション追加（他のタスクと並行可能）
2. **タスク1**: ModalContentContainerコンポーネント作成（最優先）
3. **タスク2**: CalendarModalContentContainerコンポーネント作成
4. **タスク4**: calendar/page.tsxリファクタリング
5. **タスク5**: 既存モーダルコンポーネント削除
6. **タスク6**: E2Eテスト実装（全タスク完了後）

## 成功基準

### 必須要件
- [ ] DayEvents → EventDetail遷移時にモーダル開閉アニメーションが発生しない
- [ ] コンテンツ遷移が300ms以内でスムーズに完了する
- [ ] 戻るボタンで正常にDayEventsに戻れる
- [ ] デスクトップとモバイルの両方で正常に動作する
- [ ] 既存のE2Eテストが全てパスする
- [ ] アクセシビリティチェックをパスする

### 推奨要件
- [ ] ModalContentContainerが他のユースケースでも再利用可能
- [ ] コンソールエラーが発生しない
- [ ] パフォーマンス劣化がない（Lighthouseスコア維持）
- [ ] コードカバレッジが80%以上

## 補足事項

### 将来の拡張性
ModalContentContainerは以下のようなケースでも再利用可能：
- プロフィール編集モーダル（編集 ⇄ プレビュー）
- 設定モーダル（一般設定 → 詳細設定 → アカウント設定）
- ウィザード形式のフォーム（ステップ1 → ステップ2 → ステップ3）
- 商品詳細モーダル（概要 ⇄ レビュー ⇄ 関連商品）

### 参考リンク
- 調査レポート: `docs/investigate/investigate_20251015_102250.md`
- 関連Issue: （もしあればGitHub IssueのURLを記載）

## プラン承認後の次ステップ

1. このプランをレビュー
2. 承認後、IMPLEMENTフェーズに移行
3. タスク3から実装開始（並行してタスク1）
4. 各タスク完了ごとにコミット
5. 全タスク完了後、E2Eテスト実行
6. 問題なければプルリクエスト作成