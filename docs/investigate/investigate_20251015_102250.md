# 調査レポート: モーダル間遷移時のアニメーション問題

## 調査日時
2025-10-15 10:22:50

## 調査目的
DayEventsModalとEventDetailModal間を遷移する際に、モーダルを開いた時のアニメーションが発生してしまう問題について、適切な設計パターンを複数検討し、最善の解決策を提案する。

## 要求仕様
- 画面上は常にモーダルが開いたままの状態を維持
- モーダル内のコンテンツだけが更新されるような見た目
- DayEventsModal（イベント一覧）→ EventDetailModal（イベント詳細）の遷移時にシームレス

## 現状分析

### 関連コンポーネントの構造

#### 1. DayEventsModal
- **ファイルパス**: `frontend/src/features/calendar/components/modals/DayEventsModal.tsx`
- **役割**: 特定日付のイベント一覧を表示
- **使用コンポーネント**: ResponsiveModal（mobileVariant="fullScreen"）
- **表示内容**:
  - 日付タイトル
  - イベントリスト（DayEventsList）
  - 空状態メッセージ（EmptyEventsMessage）

#### 2. EventDetailModal
- **ファイルパス**: `frontend/src/features/calendar/components/modals/EventDetailModal.tsx`
- **役割**: イベントの詳細情報を表示
- **使用コンポーネント**: ResponsiveModal（mobileVariant="fullScreen"）
- **表示内容**:
  - イベントタイトル（EventTitle）
  - イベント画像（EventImage）
  - 時間情報（EventTimeInfo）
  - 説明文（EventDescription）
- **特徴**: fromDayModal=trueの場合、戻るボタンを表示

#### 3. ResponsiveModal
- **ファイルパス**: `frontend/src/components/Modal/ResponsiveModal.tsx`
- **役割**: デスクトップとモバイルで異なるモーダルを出し分け
- **デスクトップ**: Modal（中央表示）
- **モバイル**: FullScreenModal または BottomSheet

#### 4. FullScreenModal
- **ファイルパス**: `frontend/src/components/FullScreenModal/FullScreenModal.tsx`
- **役割**: モバイルで全画面モーダルを表示
- **アニメーション**: `animate-full-screen-in`（350ms、右からスライドイン）

### 親コンポーネントの状態管理

**ファイルパス**: `frontend/src/app/calendar/page.tsx:52-62`

```typescript
const handleEventClickFromDayModal = (event: any) => {
  setIsDayEventsModalOpen(false);  // DayEventsModalを閉じる
  setSelectedEvent(event);
  setIsEventModalOpen(true);       // EventDetailModalを開く
  setFromDayModalOrSheet(true);
};

const handleBackToDayModal = () => {
  setIsEventModalOpen(false);      // EventDetailModalを閉じる
  setIsDayEventsModalOpen(true);   // DayEventsModalを開く
};
```

### 現在のアニメーション

**ファイルパス**: `frontend/src/app/globals.css:607-635`

```css
@keyframes fullScreenSlideIn {
  from {
    opacity: 0;
    transform: translateX(100%);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

.animate-full-screen-in {
  animation: fullScreenSlideIn 350ms cubic-bezier(0.16, 1, 0.3, 1) forwards;
}
```

## 問題の根本原因

### 1. 独立した状態管理
- DayEventsModalとEventDetailModalは完全に独立したコンポーネント
- それぞれが独自の`isOpen`フラグを持つ
- 遷移時に、片方が閉じて→もう片方が開く、という2段階の処理が発生

### 2. アニメーションの重複実行
- DayEventsModal: 閉じるアニメーション（`animate-full-screen-out`、250ms）
- EventDetailModal: 開くアニメーション（`animate-full-screen-in`、350ms）
- 合計約600msの間にモーダルが消えて現れる動きが発生

### 3. ユーザー体験の問題
- モーダルが一度消えることで、操作の連続性が途切れる
- スライドアニメーションが2回発生し、不自然
- 「常にモーダルが開いている」という期待と異なる動作

## 技術的制約の確認

### 既存のアーキテクチャ
```
calendar/page.tsx
├─ DayEventsModal (isOpen: isDayEventsModalOpen)
│  └─ ResponsiveModal (mobileVariant="fullScreen")
│     └─ FullScreenModal (animate-full-screen-in)
│
└─ EventDetailModal (isOpen: isEventModalOpen)
   └─ ResponsiveModal (mobileVariant="fullScreen")
      └─ FullScreenModal (animate-full-screen-in)
```

### 既存の機能要件
1. デスクトップでは中央モーダルとして表示
2. モバイルでは全画面モーダルとして表示
3. DayEventsModalから戻れるよう、backButtonの制御
4. 両方のモーダルが独立して開ける（DayEventsModalを経由せずにEventDetailModalを開く場合もある）

## 解決パターンの検討

### パターン1: 統合モーダルパターン（CalendarModal）

#### 概要
CalendarModalという新しいコンポーネントを作成し、内部でモード切り替えを管理。

```typescript
type CalendarModalMode = 'dayEvents' | 'eventDetail';

interface CalendarModalProps {
  isOpen: boolean;
  onClose: () => void;
  mode: CalendarModalMode;
  // DayEventsModal用のprops
  date: Date | null;
  events: Event[];
  // EventDetailModal用のprops
  selectedEvent: Event | null;
  // ナビゲーション
  onEventClick: (event: Event) => void;
  onBackToDayEvents: () => void;
}
```

#### メリット
1. モーダル自体は常に開いたままなので、アニメーションは発生しない
2. コンテンツ間の遷移アニメーションを完全に制御できる
3. モード切り替えが明確で理解しやすい
4. コンテンツ間の遷移を独自のアニメーション（例: フェードやスライド）にできる

#### デメリット
1. 既存の2つのモーダルコンポーネントの構造を大きく変更する必要がある
2. DayEventsModalとEventDetailModalの独立性が失われる
3. 将来的に他のモード（例: 編集モード）を追加する際、CalendarModalが肥大化する可能性

#### 実装難易度
⭐⭐⭐⭐（高）

#### 保守性
⭐⭐⭐（中）

#### UX品質
⭐⭐⭐⭐⭐（最高）

---

### パターン2: 条件付きアニメーション制御パターン

#### 概要
既存の2つのモーダルを維持しつつ、遷移元を示すフラグに基づいてアニメーションを条件付きで無効化。

```typescript
interface FullScreenModalProps {
  // 既存のprops...
  disableAnimation?: boolean;
}

// calendar/page.tsx
const [isTransitioning, setIsTransitioning] = useState(false);

const handleEventClickFromDayModal = (event: any) => {
  setIsTransitioning(true);
  setIsDayEventsModalOpen(false);
  setSelectedEvent(event);
  setIsEventModalOpen(true);
  setFromDayModalOrSheet(true);
  // アニメーション完了後にフラグをリセット
  setTimeout(() => setIsTransitioning(false), 350);
};
```

#### メリット
1. 既存のコンポーネント構造をほぼ維持できる
2. 最小限の変更で済む
3. DayEventsModalとEventDetailModalの独立性を保つ

#### デメリット
1. 複雑な状態管理が必要（タイミング制御、フラグ管理）
2. アニメーションタイミングの調整が難しい
3. 完全にシームレスにするのは困難（一瞬の空白が発生する可能性）
4. setTimeoutなどの時間ベースの制御が必要で、パフォーマンス環境に依存

#### 実装難易度
⭐⭐⭐（中）

#### 保守性
⭐⭐（低）

#### UX品質
⭐⭐⭐（中）

---

### パターン3: z-indexオーバーラップパターン

#### 概要
両方のモーダルを同時に開いた状態にし、z-indexとopacityで表示を切り替える。

```typescript
// DayEventsModalは常にz-index: 50
// EventDetailModalはz-index: 51

const handleEventClickFromDayModal = (event: any) => {
  // DayEventsModalは閉じない
  setSelectedEvent(event);
  setIsEventModalOpen(true);  // EventDetailModalを上に重ねる
  setFromDayModalOrSheet(true);
};

const handleBackToDayModal = () => {
  setIsEventModalOpen(false);  // EventDetailModalを閉じる
  // DayEventsModalは既に開いている
};
```

#### メリット
1. モーダル開閉アニメーションが発生しない
2. 実装が比較的シンプル
3. 戻る時の動作もスムーズ

#### デメリット
1. DOMに両方のモーダルが常に存在することになる
2. パフォーマンスへの影響（特にモバイル）
3. アクセシビリティの問題（ARIAの管理が複雑）
4. フォーカス管理が複雑になる
5. DayEventsModalを経由せずにEventDetailModalを開く場合に対応できない

#### 実装難易度
⭐⭐（低）

#### 保守性
⭐⭐（低）

#### UX品質
⭐⭐⭐⭐（高）

---

### パターン4: コンテンツコンテナパターン

#### 概要
ResponsiveModalやFullScreenModalの中に、コンテンツを切り替えるコンテナを配置。

```typescript
interface ModalContentContainerProps {
  currentContent: 'dayEvents' | 'eventDetail';
  dayEventsContent: React.ReactNode;
  eventDetailContent: React.ReactNode;
}

// FullScreenModal内で
<FullScreenModal isOpen={isModalOpen} onClose={onClose}>
  <ModalContentContainer
    currentContent={currentContentType}
    dayEventsContent={<DayEventsContent />}
    eventDetailContent={<EventDetailContent />}
  />
</FullScreenModal>
```

#### メリット
1. モーダル自体は開いたまま、コンテンツだけを切り替え
2. コンテンツ間の遷移アニメーション（フェード、スライドなど）を自由に設定可能
3. FullScreenModalのロジックをそのまま活用できる
4. コンテンツコンポーネントは分離されたまま

#### デメリット
1. コンテンツラッパーの実装が必要
2. 親コンポーネント（calendar/page.tsx）のロジックを変更する必要がある
3. モーダルのタイトルや戻るボタンの制御が複雑になる

#### 実装難易度
⭐⭐⭐（中）

#### 保守性
⭐⭐⭐⭐（高）

#### UX品質
⭐⭐⭐⭐⭐（最高）

---

### パターン5: アニメーション遅延戦略パターン

#### 概要
モーダル間の遷移時に、閉じるアニメーションを無効化し、開くアニメーションのみを実行。

```typescript
// FullScreenModalに新しいpropsを追加
interface FullScreenModalProps {
  // 既存...
  animationType?: 'enter' | 'exit' | 'both' | 'none';
}

// 遷移時
const handleEventClickFromDayModal = (event: any) => {
  setDayEventsAnimationType('none');  // 閉じるアニメーションを無効化
  setIsDayEventsModalOpen(false);

  setSelectedEvent(event);
  setEventDetailAnimationType('enter');  // 開くアニメーションのみ
  setIsEventModalOpen(true);
  setFromDayModalOrSheet(true);
};
```

#### メリット
1. 既存のコンポーネント構造を維持
2. アニメーションの重複実行を防げる
3. 実装が比較的シンプル

#### デメリット
1. 完全にシームレスではない（一瞬の空白が発生する可能性）
2. 状態管理が増える
3. 中途半端な解決策で、根本的な問題は解決していない

#### 実装難易度
⭐⭐（低）

#### 保守性
⭐⭐⭐（中）

#### UX品質
⭐⭐⭐（中）

---

## 各パターンの総合評価

| パターン | 実装難易度 | 保守性 | UX品質 | 既存コードへの影響 | パフォーマンス | アクセシビリティ |
|---------|-----------|--------|--------|------------------|--------------|----------------|
| 1. 統合モーダル | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 大 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 2. 条件付きアニメーション | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ | 小 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| 3. z-indexオーバーラップ | ⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ | 中 | ⭐⭐ | ⭐⭐ |
| 4. コンテンツコンテナ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 中 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 5. アニメーション遅延戦略 | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | 小 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |

## 推奨する解決策

### 第1推奨: パターン4（コンテンツコンテナパターン）

#### 推奨理由
1. **最高のUX品質**: モーダルが常に開いたまま、コンテンツだけがシームレスに切り替わる
2. **高い保守性**: コンテンツコンポーネント（DayEventsList、EventDetail）は分離されたまま
3. **柔軟性**: コンテンツ間の遷移アニメーションを自由にカスタマイズ可能
4. **適度な実装難易度**: 新しいコンテナコンポーネントの追加のみ
5. **パフォーマンス**: 不要なDOMの重複がない
6. **アクセシビリティ**: 単一モーダルのため、ARIAやフォーカス管理がシンプル

#### 実装の詳細設計

##### 新規コンポーネント: CalendarModalContentContainer

```typescript
// frontend/src/features/calendar/components/modals/internals/CalendarModalContentContainer.tsx

interface CalendarModalContentContainerProps {
  mode: 'dayEvents' | 'eventDetail';
  date: Date | null;
  events: Event[];
  selectedEvent: Event | null;
  onEventClick: (event: Event) => void;
}

export const CalendarModalContentContainer = ({
  mode,
  date,
  events,
  selectedEvent,
  onEventClick
}: CalendarModalContentContainerProps) => {
  return (
    <div className="relative w-full h-full">
      <div
        className={cn(
          'absolute inset-0 transition-all duration-300',
          mode === 'dayEvents' ? 'opacity-100 translate-x-0' : 'opacity-0 -translate-x-full pointer-events-none'
        )}
      >
        {/* DayEventsModalのコンテンツ */}
        {events.length === 0 ? (
          <EmptyEventsMessage />
        ) : (
          <DayEventsList events={events} onEventClick={onEventClick} />
        )}
      </div>

      <div
        className={cn(
          'absolute inset-0 transition-all duration-300',
          mode === 'eventDetail' ? 'opacity-100 translate-x-0' : 'opacity-0 translate-x-full pointer-events-none'
        )}
      >
        {/* EventDetailModalのコンテンツ */}
        {selectedEvent && (
          <div className="space-y-4">
            <EventTitle event={selectedEvent} />
            <EventImage event={selectedEvent} />
            <EventTimeInfo event={selectedEvent} />
            <EventDescription event={selectedEvent} />
          </div>
        )}
      </div>
    </div>
  );
};
```

##### calendar/page.tsxの修正

```typescript
// 状態を統合
const [calendarModalOpen, setCalendarModalOpen] = useState(false);
const [calendarModalMode, setCalendarModalMode] = useState<'dayEvents' | 'eventDetail'>('dayEvents');

const handleEventClickFromDayModal = (event: any) => {
  setSelectedEvent(event);
  setCalendarModalMode('eventDetail');  // モードを切り替えるだけ
  setFromDayModalOrSheet(true);
};

const handleBackToDayModal = () => {
  setCalendarModalMode('dayEvents');  // モードを切り替えるだけ
};

// 単一のモーダル
<ResponsiveModal
  isOpen={calendarModalOpen}
  onClose={handleCloseModal}
  title={calendarModalMode === 'dayEvents'
    ? `${selectedDate?.toLocaleDateString('ja-JP')}のイベント`
    : 'イベント詳細'
  }
  backButton={calendarModalMode === 'eventDetail' && fromDayModalOrSheet ? {
    show: true,
    onClick: handleBackToDayModal
  } : undefined}
  mobileVariant="fullScreen"
>
  <CalendarModalContentContainer
    mode={calendarModalMode}
    date={selectedDate}
    events={selectedDateEvents}
    selectedEvent={selectedEvent}
    onEventClick={handleEventClickFromDayModal}
  />
</ResponsiveModal>
```

#### この実装のメリット
1. モーダル自体は開きっぱなし → アニメーションが発生しない
2. コンテンツの切り替えは300msのフェード + スライド → スムーズな遷移
3. DOMには表示中のコンテンツのみが有効 → パフォーマンス良好
4. タイトルや戻るボタンの制御も統合されて分かりやすい
5. 既存のDayEventsList、EventTitle等のコンポーネントはそのまま再利用

### 第2推奨: パターン1（統合モーダルパターン）

より大規模なリファクタリングが許容される場合、CalendarModal全体を統合する方法も検討価値あり。

#### 推奨する場合
- 将来的にカレンダーモーダルに編集機能などを追加する予定がある
- モーダル全体の責務を明確にしたい
- 長期的な保守性を重視

## 次のステップ（Planフェーズへの推奨事項）

### 実装タスク
1. CalendarModalContentContainerコンポーネントの新規作成
2. calendar/page.tsxの状態管理をリファクタリング
   - 個別の状態（isDayEventsModalOpen、isEventModalOpen）を統合
   - モード管理の追加（calendarModalMode）
3. ResponsiveModalの統合（単一のResponsiveModalで両方のコンテンツを管理）
4. コンテンツ遷移アニメーションのCSSクラス追加
5. DayEventsModalとEventDetailModalコンポーネントの削除または非推奨化

### テストシナリオ（E2E with Playwright）
1. カレンダーから日付をクリック → DayEventsModalが開く
2. イベントをクリック → EventDetailModalに遷移（アニメーションなし）
3. 戻るボタンをクリック → DayEventsModalに戻る（アニメーションなし）
4. 閉じるボタンをクリック → モーダルが閉じる
5. デスクトップ表示でも正常に動作することを確認
6. 直接EventDetailModalを開くケースも正常に動作することを確認

### 確認事項
- コンテンツ遷移のアニメーション（フェード、スライド）のタイミング
- モバイルでの全画面表示が正常に動作するか
- デスクトップでの中央モーダル表示が正常に動作するか
- アクセシビリティ（フォーカス管理、ARIAラベル）

## まとめ

DayEventsModalとEventDetailModal間の遷移時にアニメーションが発生する問題は、2つのモーダルが独立して管理されていることが根本原因。

**推奨解決策**: コンテンツコンテナパターン（パターン4）
- 単一のResponsiveModalの中でコンテンツを切り替える
- モーダル自体は常に開いたまま、中身だけがシームレスに遷移
- 実装難易度と効果のバランスが最も良い
- 保守性、パフォーマンス、アクセシビリティ全てで高評価

この方針により、ユーザーが期待する「常にモーダルが開いたままで、コンテンツだけが更新される」体験を実現できる。
