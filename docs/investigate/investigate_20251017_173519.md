# 調査報告書: SPECIALS イベントタイプ機能追加

## 調査日時
2025-10-17 17:35:19

## 調査対象
SPECIALSにイベントタイプ機能を追加し、Messages用の詳細画面を実装する

## 調査概要

### 目的
- イベントをタイプごとに管理できるようにする
- イベントタイプのマスタテーブルとspecial_eventsとのリレーションテーブルを作成
- イベントカード選択時に詳細画面に遷移
- Messages用の詳細画面でmessagesテーブルから取得したメッセージを表示

## 既存システムの調査結果

### 1. データベース構造

#### 既存のspecial_eventsテーブル
**ファイル**: `backend/src/main/resources/db/changelog/changes/035-create-special-events-table.sql`

```sql
CREATE TABLE special_events (
    id UUID PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    start_date DATE NOT NULL,
    end_date DATE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**カラム構成**:
- id: UUID型の主キー
- title: イベントタイトル
- description: イベント説明
- start_date: 開始日
- end_date: 終了日
- created_at: 作成日時

**インデックス**:
- idx_special_events_start_date
- idx_special_events_end_date
- idx_special_events_title
- idx_special_events_date_range

#### 参考: カレンダーのevent_types実装パターン
**ファイル**: `backend/src/main/resources/db/changelog/changes/021-create-calendar-tables.sql`

カレンダー機能では既にイベントタイプのマスタとリレーションテーブルのパターンが実装されている:

```sql
-- イベントタイプマスタテーブル
CREATE TABLE event_types (
    id SERIAL PRIMARY KEY,
    type VARCHAR(30) NOT NULL UNIQUE
);

-- イベントとイベントタイプの中間テーブル
CREATE TABLE event_event_types (
    event_id BIGINT NOT NULL,
    event_type_id INTEGER NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (event_id, event_type_id)
);
```

このパターンを参考にspecial_event_types、special_event_special_event_typesテーブルを設計する。

### 2. バックエンド構造

#### アーキテクチャ
- **言語**: Kotlin
- **フレームワーク**: Spring Boot
- **データベース**: PostgreSQL + R2DBC
- **マイグレーション**: Liquibase
- **設計パターン**: ドメイン駆動設計

#### レイヤー構成
```
adapter/
├── controller/          # コントローラー層
│   ├── SpecialsController.kt
│   ├── dto/            # データ転送オブジェクト
│   │   └── SpecialEventDto.kt
│   └── port/           # ポート（インターフェース）
│       └── SpecialsUseCasePort.kt
├── gateway/            # ゲートウェイ層（データアクセス）
│   ├── SpecialEventRepositoryImpl.kt
│   ├── entity/
│   │   └── SpecialEventEntities.kt
│   ├── mapper/
│   │   └── SpecialEventRowMapper.kt
│   ├── query/
│   │   └── SpecialEventQueryBuilder.kt
│   └── model/
│       └── SpecialEventSearchCriteria.kt
application/
└── usecase/            # ユースケース層
    └── SpecialsUseCaseImpl.kt
domain/
├── model/              # ドメインモデル
│   └── SpecialEvent.kt
└── repository/         # リポジトリインターフェース
    └── SpecialEventRepository.kt
```

#### 既存API
**ファイル**: `backend/src/main/kotlin/com/shirogane/holy/knights/infrastructure/lambda/ApiGatewayRouter.kt`

```kotlin
RouteKey("GET", "/specials") to { _ ->
    specialsController.getSpecialEvents()
},
// パスパラメータ対応
if (httpMethod == "GET" && path.startsWith("/specials/") && path != "/specials/") {
    val eventId = path.removePrefix("/specials/")
    if (eventId.isNotBlank()) {
        return { _ -> specialsController.getSpecialEventDetails(eventId) }
    }
}
```

#### ドメインモデル
**ファイル**: `backend/src/main/kotlin/com/shirogane/holy/knights/domain/model/SpecialEvent.kt`

```kotlin
data class SpecialEvent(
    val id: SpecialEventId,
    val title: String,
    val description: String,
    val startDate: LocalDate,
    val endDate: LocalDate,
    val status: SpecialEventStatus
)

enum class SpecialEventStatus {
    UPCOMING,
    ACTIVE,
    ENDED
}
```

#### エンティティとマッピング
**ファイル**: `backend/src/main/kotlin/com/shirogane/holy/knights/adapter/gateway/entity/SpecialEventEntities.kt`

- ステータスはDBに保存せず、start_dateとend_dateから動的に計算
- エンティティからドメインモデルへの変換メソッド（toDomain()）を実装

### 3. フロントエンド構造

#### 技術スタック
- **フレームワーク**: Next.js 13+ (App Router)
- **言語**: TypeScript
- **UI**: React + Tailwind CSS

#### ディレクトリ構成
```
frontend/src/
├── app/
│   └── specials/
│       ├── page.tsx        # メインページ
│       └── layout.tsx      # レイアウト
└── features/
    └── specials/
        ├── api/
        │   └── specialClient.ts
        ├── components/
        │   ├── cards/
        │   │   ├── SpecialEventCard.tsx
        │   │   └── SkeletonSpecialEventCard.tsx
        │   └── grids/
        │       └── SpecialsGrid.tsx
        ├── hooks/
        │   └── useSpecials.ts
        └── types/
            └── types.ts
```

#### 現在の実装
**ファイル**: `frontend/src/app/specials/page.tsx`

```typescript
const handleEventClick = (event: SpecialEventDto) => {
  console.log('Event clicked:', event);
};
```

現在はカードクリック時にconsole.logのみ。詳細画面への遷移は未実装。

#### 型定義
**ファイル**: `frontend/src/features/specials/types/types.ts`

```typescript
export interface SpecialEventDto {
  id: string;
  title: string;
  description: string;
  startDate: string;
  endDate: string;
  status: 'upcoming' | 'active' | 'ended';
}
```

### 4. 参考実装: カレンダーの詳細表示

カレンダー機能ではモーダルで詳細を表示している:

**ファイル**: `frontend/src/features/calendar/components/modals/internals/EventDetailContent.tsx`

```typescript
export function EventDetailContent({ event }: EventDetailContentProps) {
  if (!event) return null;

  return (
    <div className="space-y-4">
      <EventTitle event={event} />
      <EventImage event={event} />
      <EventTimeInfo event={event} />
      <EventDescription event={event} />
    </div>
  );
}
```

SPECIALSでは専用ページでの詳細表示を実装する方針とする。

## 技術的制約と可能性

### 制約事項
1. **マイグレーション番号**: 次は036番を使用
2. **Liquibase形式**: 既存のフォーマットに従う
3. **R2DBC**: リアクティブなデータアクセス必須
4. **UUIDとSERIAL**: special_eventsはUUID、マスタテーブルはSERIALを使用（カレンダーパターン踏襲）
5. **ドメインモデル不変**: 既存のドメインモデルに影響を与えない拡張

### 可能性
1. **カレンダーパターンの再利用**: event_typesの実装パターンを流用可能
2. **段階的拡張**: 将来的に他のイベントタイプ追加が容易
3. **モジュール化**: メッセージ表示コンポーネントを他でも再利用可能

## 実装方針

### 1. データベース設計

#### マイグレーションファイル: 036-create-special-event-types-tables.sql

```sql
-- 1. special_event_typesマスタテーブル
CREATE TABLE special_event_types (
    id SERIAL PRIMARY KEY,
    type VARCHAR(30) NOT NULL UNIQUE
);

CREATE INDEX idx_special_event_types_type ON special_event_types(type);

INSERT INTO special_event_types (type) VALUES ('messages');

-- 2. special_event_special_event_typesリレーションテーブル
CREATE TABLE special_event_special_event_types (
    special_event_id UUID NOT NULL,
    special_event_type_id INTEGER NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (special_event_id, special_event_type_id)
);

ALTER TABLE special_event_special_event_types
    ADD CONSTRAINT fk_special_event_id
    FOREIGN KEY (special_event_id) REFERENCES special_events(id) ON DELETE CASCADE;

ALTER TABLE special_event_special_event_types
    ADD CONSTRAINT fk_special_event_type_id
    FOREIGN KEY (special_event_type_id) REFERENCES special_event_types(id) ON DELETE RESTRICT;

CREATE INDEX idx_special_event_special_event_types_special_event_id
    ON special_event_special_event_types(special_event_id);
CREATE INDEX idx_special_event_special_event_types_special_event_type_id
    ON special_event_special_event_types(special_event_type_id);

-- 3. messagesテーブル
CREATE TABLE messages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    special_event_id UUID NOT NULL,
    name VARCHAR(255) NOT NULL,
    message TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

ALTER TABLE messages
    ADD CONSTRAINT fk_messages_special_event_id
    FOREIGN KEY (special_event_id) REFERENCES special_events(id) ON DELETE CASCADE;

CREATE INDEX idx_messages_special_event_id ON messages(special_event_id);
CREATE INDEX idx_messages_created_at ON messages(created_at);
```

### 2. バックエンド実装計画

#### Entity追加
- `SpecialEventTypeEntity`: special_event_typesテーブルのマッピング
- `MessageEntity`: messagesテーブルのマッピング
- `SpecialEventEntity`にeventTypesプロパティ追加

#### Mapper拡張
- `SpecialEventRowMapper`: JOINしたタイプ情報を含める
- `MessageRowMapper`: 新規作成

#### QueryBuilder拡張
- `SpecialEventQueryBuilder`: タイプとメッセージを含むJOIN処理追加
- `MessageQueryBuilder`: 新規作成（special_event_id による取得）

#### Repository拡張
- `SpecialEventRepository`: メッセージ取得メソッド追加
- または `MessageRepository`: 新規作成

#### UseCase拡張
- `SpecialsUseCaseImpl`: 詳細取得時にメッセージも含める

#### DTO拡張
```kotlin
data class SpecialEventDto(
    val id: String,
    val title: String,
    val description: String,
    val startDate: String,
    val endDate: String,
    val status: String,
    val eventTypes: List<String> = emptyList() // 追加
)

data class MessageDto(
    val id: String,
    val name: String,
    val message: String,
    val createdAt: String
)

data class SpecialEventDetailDto(
    val event: SpecialEventDto,
    val messages: List<MessageDto> = emptyList()
)
```

### 3. フロントエンド実装計画

#### 詳細ページ作成
- `app/specials/[id]/page.tsx`: 詳細ページ
- `app/specials/[id]/layout.tsx`: 詳細ページレイアウト（必要に応じて）

#### コンポーネント作成
- `features/specials/components/details/SpecialEventDetail.tsx`: 詳細表示メインコンポーネント
- `features/specials/components/messages/MessagesList.tsx`: メッセージリスト
- `features/specials/components/messages/MessageCard.tsx`: メッセージカード

#### API拡張
```typescript
export const SpecialApi = {
  getSpecialEventDetails: (eventId: string): Promise<SpecialEventDetailDto> => {
    return apiClient.get<SpecialEventDetailDto>(`/specials/${eventId}`);
  }
};
```

#### 型定義拡張
```typescript
export interface MessageDto {
  id: string;
  name: string;
  message: string;
  createdAt: string;
}

export interface SpecialEventDetailDto {
  event: SpecialEventDto;
  messages: MessageDto[];
}
```

#### ルーティング修正
`page.tsx`のhandleEventClickでページ遷移:
```typescript
const router = useRouter();

const handleEventClick = (event: SpecialEventDto) => {
  router.push(`/specials/${event.id}`);
};
```

## 既存システムとの整合性

### 1. カレンダー機能との整合性
- event_typesと同じパターンでspecial_event_typesを実装
- リレーションテーブルのネーミング規則を踏襲
- 外部キー制約の設定方法を統一

### 2. 他機能との整合性
- ドメイン駆動設計のレイヤー構成を維持
- エンティティ→ドメインモデル→DTOの変換パターンを踏襲
- APIレスポンス形式の統一（PaginatedResult等）

### 3. コーディング規約
- Kotlinのデータクラス使用
- 不変オブジェクト指向
- Arrowライブラリによるエラーハンドリング（Either型）
- TypeScriptのインターフェース定義

## リスク分析

### 高リスク
なし

### 中リスク
1. **既存データとの整合性**: 既存のspecial_eventsデータにタイプが紐づいていない
   - **対策**: マイグレーション実行後にデフォルトのタイプを割り当てるスクリプト作成

### 低リスク
1. **パフォーマンス**: JOIN処理の増加
   - **対策**: 適切なインデックス設定済み

## 次フェーズへの推奨事項

### Planフェーズで実施すべきこと
1. 詳細な実装手順の策定
2. テストケースの設計
3. データ投入スクリプトの設計
4. ロールバック手順の確認

### Implementフェーズで実施すべきこと
1. マイグレーションファイル作成
2. バックエンド実装（Entity → Mapper → QueryBuilder → Repository → UseCase → Controller）
3. フロントエンド実装（型定義 → API → コンポーネント → ページ）
4. データ投入スクリプト作成
5. ユニットテスト作成
6. Playwright MCPツールでのE2Eテスト

### Testフェーズで実施すべきこと
1. 機能テスト（CRUD操作）
2. E2Eテスト（ユーザー視点の動作確認）
3. パフォーマンステスト（JOIN処理の負荷確認）
4. ロールバックテスト

## 結論

### 実装可否判定
**実装推奨**

### 理由
1. カレンダー機能で既に同様のパターンが実装されており、参考にできる
2. 既存のアーキテクチャに沿った自然な拡張が可能
3. 技術的リスクは低く、対策も明確
4. 将来的な拡張性も確保できる

### 推定工数
- データベース設計・実装: 2時間
- バックエンド実装: 4時間
- フロントエンド実装: 4時間
- テスト・デバッグ: 2時間
- 合計: 約12時間

### 次のステップ
1. Planフェーズに移行
2. 詳細な実装計画の策定
3. 実装開始

## 参考資料

### 参照したファイル
- backend/src/main/resources/db/changelog/changes/035-create-special-events-table.sql
- backend/src/main/resources/db/changelog/changes/021-create-calendar-tables.sql
- backend/src/main/kotlin/com/shirogane/holy/knights/domain/model/SpecialEvent.kt
- backend/src/main/kotlin/com/shirogane/holy/knights/adapter/controller/SpecialsController.kt
- backend/src/main/kotlin/com/shirogane/holy/knights/adapter/gateway/entity/SpecialEventEntities.kt
- backend/src/main/kotlin/com/shirogane/holy/knights/adapter/gateway/entity/CalendarEntities.kt
- frontend/src/app/specials/page.tsx
- frontend/src/features/specials/types/types.ts
- frontend/src/features/calendar/components/modals/internals/EventDetailContent.tsx

### 関連ドキュメント
- Spring Boot R2DBC Documentation
- Liquibase Documentation
- Next.js App Router Documentation
